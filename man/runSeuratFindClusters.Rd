% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scanpyFunctions.R, R/seuratFunctions.R
\name{runSeuratFindClusters}
\alias{runSeuratFindClusters}
\title{runScanpyFindClusters
Computes the clusters from the input sce object and stores them back in sce
object}
\usage{
runSeuratFindClusters(
  inSCE,
  useAssay = "seuratScaledData",
  useReduction = c("pca", "ica"),
  dims = 10,
  algorithm = c("louvain", "multilevel", "SLM"),
  groupSingletons = TRUE,
  resolution = 0.8,
  externalReduction = NULL,
  verbose = TRUE
)

runSeuratFindClusters(
  inSCE,
  useAssay = "seuratScaledData",
  useReduction = c("pca", "ica"),
  dims = 10,
  algorithm = c("louvain", "multilevel", "SLM"),
  groupSingletons = TRUE,
  resolution = 0.8,
  externalReduction = NULL,
  verbose = TRUE
)
}
\arguments{
\item{inSCE}{(sce) object from which clusters should be computed and stored
in}

\item{useAssay}{Assay containing scaled counts to use for clustering.}

\item{useReduction}{Reduction method to use for computing clusters. One of
"pca" or "ica". Default \code{"pca"}.}

\item{dims}{numeric value of how many components to use for computing
clusters. Default \code{10}.}

\item{algorithm}{selected algorithm to compute clusters. One of "louvain",
"multilevel", or "SLM". Use \code{louvain} for "original Louvain algorithm"
and \code{multilevel} for "Louvain algorithm with multilevel refinement".
Default \code{louvain}.}

\item{groupSingletons}{boolean if singletons should be grouped together or
not. Default \code{TRUE}.}

\item{resolution}{Set the resolution parameter to find larger (value above 1)
or smaller (value below 1) number of communities. Default \code{0.8}.}

\item{externalReduction}{Pass DimReduc object if PCA/ICA computed through
other libraries. Default \code{NULL}.}

\item{verbose}{Logical value indicating if informative messages should
be displayed. Default is \code{TRUE}.}

\item{nNeighbors}{The size of local neighborhood (in terms of number of 
neighboring data points) used for manifold approximation. Larger values 
result in more global views of the manifold, while smaller values result in 
more local data being preserved. Default \code{15L}.}

\item{colDataName}{colName to store the result in annData object}

\item{niterations}{How many iterations of the Leiden clustering algorithm to 
perform. Positive values above 2 define the total number of iterations to 
perform, -1 has the algorithm run until it reaches its optimal clustering.}

\item{flavor}{Choose between to packages for computing the clustering.}

\item{use_weights}{Boolean. Use weights from knn graph.}

\item{cor_method}{correlation method to use. Options are ‘pearson’, 
‘kendall’, and ‘spearman’. Default 'pearson'.}

\item{inplace}{If True, adds dendrogram information to annData object, 
else this function returns the information.}
}
\value{
Updated sce object which now contains the computed clusters

Updated sce object which now contains the computed clusters
}
\description{
runScanpyFindClusters
Computes the clusters from the input sce object and stores them back in sce
object

runSeuratFindClusters
Computes the clusters from the input sce object and stores them back in sce
object
}
\examples{
data(scExample, package = "singleCellTK")
\dontrun{
sce <- runScanpyNormalizeData(sce, useAssay = "counts")
sce <- runScanpyFindHVG(sce, useAssay = "counts")
sce <- runScanpyScaleData(sce, useAssay = "counts")
sce <- runScanpyPCA(sce, useAssay = "counts")
sce <- runScanpyFindClusters(sce, useAssay = "counts")
}
data(scExample, package = "singleCellTK")
\dontrun{
sce <- runSeuratNormalizeData(sce, useAssay = "counts")
sce <- runSeuratFindHVG(sce, useAssay = "counts")
sce <- runSeuratScaleData(sce, useAssay = "counts")
sce <- runSeuratPCA(sce, useAssay = "counts")
sce <- runSeuratFindClusters(sce, useAssay = "counts")
}
}
