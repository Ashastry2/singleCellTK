---
title: "Importing and Quality Control Tutorial - PBMC3K"
author: "Yichen Wang"
output:
  html_document:
    toc: true
    toc_depth: 5
bibliography: references.bib
csl: ieee.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, message=FALSE, warning=FALSE)
```

````{=html}
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
````

## Introduction

Single Cell Toolkit (singleCellTK, SCTK) is a package that works on single-cell RNA-seq (scRNAseq) dataset. SCTK allows users to import multiple datasets, perform quality control and a series of preprocessing, get clustering on cells and markers of clusters, and run various downstream analysis. Meanwhile, SCTK also wraps curated workflows for [celda](https://www.camplab.net/celda/) and [Seurat](https://satijalab.org/seurat/). 

The SCTK tutorial series start from importing, QC and filtering. After this, users can go through either the [A La Carte Workflow](02_a_la_carte_workflow.html) or the Curated Workflows ([Seurat](seurat_curated_workflow.html) or [Celda](celda_curated_workflow.html)). These tutorials will take the real-world scRNAseq dataset as an example, which consists of 2,700 Peripheral Blood Mononuclear Cells (PBMCs) collected from a healthy donor, namingly PBMC3K. This dataset is available from 10X Genomics and can be found on the 10X website.

Before starting the analysis from either UI or console, users should have SCTK properly installed first. Please refer to the [Installation](installation.html) documentation for detail of installing the `singleCellTK` package and relevant dependencies. Alternatively, users can also access the functionality by visiting our <a href="https://sctk.bu.edu/" target="_blank">online web server deployment https://sctk.bu.edu/</a>, or using a stand-alone [docker image](https://hub.docker.com/r/campbio/sctk_shiny). 

## Importing Data

SCTK allows importing dataset from various type of sources, such as preprocessing tools like cellranger or flat text files. SCTK also allows importing multiple batches (samples) of dataset at the same time. Please refer to the [detailed documentation of Importing](import_data.html) for different ways of importing. This tutorial only shows how we can import the example PBMC3K data.

````{=html}
<div class="tabset" id="tabset1">
<div class="tab">
  <button class="tablinks ia" onclick="openTab(event, 'ia', 'tabset1')">Interactive Analysis</button>
  <button class="tablinks console" onclick="openTab(event, 'console', 'tabset1')">Console Analysis</button>
</div>

<div class="tabcontent ia">
````

After starting the UI, the landing page will be for importing the scRNAseq data. To import the PBMC3K dataset previously mentioned, users should follow these steps:

![import](ui_screenshots/ui_tutorial/import_1.png)\

1. If you are not already at the starting import page, you start by going to the **Data** tab and selecting the **Import Single Cell Data** option (2). 

![import](ui_screenshots/ui_tutorial/import_2.png)\

3. Select the relevant way to import data. For the purpose of this example, we use pbmc3k filtered raw data using the **CellRanger** option. This data can be downloaded from [here](https://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz). 

![import](ui_screenshots/ui_tutorial/import_3.png)\

4. In the appropriate input boxes, we select the matrix, feature and barcode files and upload each sample individually by giving a unique sample name (5). 

![import](ui_screenshots/ui_tutorial/import_4.png)\

6. Now either **import** samples or **Add one more sample**. You can keep adding more samples until all samples have been added and then finally import all of them together.

![import](ui_screenshots/ui_tutorial/import_5.png)\

After successfully importing, the third collapse box will pop up and show users the basic summary stats of the imported dataset. Meanwhile, users can set feature display options here. Most of the time, the dataset has default feature ID (usually seen as row names of a matrix) together with other types of ID (e.g. symbol) in the feature metadata. The first option **"Set feature ID"** sets the type of default feature ID, which should be unique and has no `NA` value. The second option **"Set feature names to be displayed in downstream visualization"** does what it says. When we need to show features on a plot, such as a heatmap or a volcano plot, usually it is better to show gene symbols rather than ensembl IDs. 

````{=html}
</div>
<div class="tabcontent console">
````

Here we use `importExampleData()` to load PBMC3k data from the Bioconductor package [TENxPBMCData](https://bioconductor.org/packages/release/data/experiment/html/TENxPBMCData.html).  

```{R import, results='hold'}
library(singleCellTK)
sce <- importExampleData("pbmc3k")
```

An [`SingleCellExperiment`](https://rdrr.io/bioc/SingleCellExperiment/man/SingleCellExperiment.html) (SCE) object is returned as the data container. An SCE object is designed for storing and manipulating expression matrices, gene/cell metadata, low-dimension representation and unstructured information. All the methods wrapped by SCTK will be performed on the SCE object. 

**Importing CellRanger Output Data**

Here, we briefly introduce the approach to importing the output of the widely used preprocessing tool, `cellranger`. SCTK has a generic function `importCellRanger()` for this purpose, and, explicitly, `importCellRangerV2()` and `importCellRangerV3()` for different versions of `cellranger`. For the detail of these functions, please click on the function names to be redirected to the reference page. 

The input arguments basically asks users what the exact paths of the input data files are (i.e. `"matrix.mtx"`, `"features.tsv"`, and `"barcodes.tsv"`). They are `cellRangerDirs`, `sampleDirs`, `cellRangerOuts`, `matrixFileNames`, `featuresFileNames` and `barcodesFileNames`. And the function will identify the specified path, for example, of the barcode file, as a combination of: `{cellRangerDirs}/{sampleDirs}/{cellRangerOuts}/{barcodesFileNames}`. Theses functions automatically try to recognize a preset substucture of `cellRangerDirs`, so that in most of the cases, users only need to specify `cellRangerDirs` to tell where the top level directory of the output is. However, sometimes the three essential files may be placed or named in a different way and the default detection method won't find them. In this case, users will need to check the exact paths and manually specify the correct input according to the combination rule above and the error messages. 

An example folder structure:

```
./datasets/
    sample1/
        outs/filtered_feature_bc_matrix/
            barcodes.tsv.gz
            features.tsv.gz
            matrix.mtx.gz
    sample2/
        outs/filtered_feature_bc_matrix/
            barcodes.tsv.gz
            features.tsv.gz
            matrix.mtx.gz
./otherCellRangerData/
    barcodes.tsv
    genes.tsv
    matrix.mtx
```

```{R, eval=FALSE}
# Default use case
sce <- importCellRanger(cellRangerDirs = "dataset")
# In case the three files are placed in a different way
sce <- importCellRanger(sampleDirs = "otherCellRangerData",
                        cellRangerOuts = "",
                        barcodesFileNames = "barcodes.tsv",
                        featuresFileNames = "genes.tsv",
                        matrixFileNames = "matrix.mtx")
```

````{=html}
</div>
</div>
````

## Quality Control

Quality control of cells is often needed before downstream analyses such as dimension reduction and clustering. Typical filtering procedures include exclusion of poor quality cells with low numbers of counts/UMIs, estimation and removal of ambient RNA, and identification of potential doublet/multiplets. Many tools and packages are available to perform these operations and users are free to apply their tool(s) of choice with SCTK. 

Below is a quick example of how to perform standard QC before heading to the downstream analyses. If your data is already QC'ed or you decide to skip this step, you can directly move to the workflows ([A La Carte](02_a_la_carte_workflow.html), [Seurat](seurat_curated_workflow.html) or [Celda](celda_curated_workflow.html)). For this tutorial, we will only run one doublet detection algorithm ([scDblFinder](https://bioconductor.org/packages/release/bioc/html/scDblFinder.html)) and one decontamination algorithm ([decontX](https://rdrr.io/bioc/celda/man/decontX.html)). We will also quantify the percentage of mitochondrial genes in each cell as this is often used as a measure of cell viability. 

````{=html}
<!--Remember to change tabset id-->
<div class="tabset" id="tabset2">
<div class="tab">
  <!--Remember to change tabset id argument of `openTab`-->
  <button class="tablinks ia" onclick="openTab(event, 'ia', 'tabset2')">Interactive Analysis</button>
  <button class="tablinks console" onclick="openTab(event, 'console', 'tabset2')">Console Analysis</button>
</div>

<div class="tabcontent ia">
````

**Running QC methods**

![import](ui_screenshots/ui_tutorial/qc_run.png)\

1. Users need to select **"QC & Filtering"** at the top navigation panel to enter this section. 
2. In this tutorial, we perform General **"QC Metrics"**, decontamination algorithm [**"decontX"**](https://rdrr.io/bioc/celda/man/decontX.html) and doublet detection algorithm [**"scDblFinder"**](https://bioconductor.org/packages/release/bioc/html/scDblFinder.html), by checking the corresponding method in the left panel of this page. 
3. After making the selection of methods, users can then click on **"Run"** button at the bottom of the left panel. 

![import](ui_screenshots/ui_tutorial/qc_plot.png)\

Right after running, the visualization of QC results will automatically show up in the right main panel, with tabs for different methods. 

Please find [the detailed documentation of the QC UI](ui_qc.html) for more explanation of each parameter. 

````{=html}
</div>
<div class="tabcontent console">
````

**Running QC methods**

To perform QC, we suggest using the `runCellQC()` function. This is a wrapper for several methods for calculation of QC metrics, doublet detection, and estimation of ambient RNA. For a full list of algorithms that this function runs by default, see `?runCellQC`. 

```{R qc, results='hold'}
# Run QC
sce <- runCellQC(sce, sample = NULL,
                 algorithms = c("QCMetrics", "scDblFinder", "decontX"),
                 mitoRef = "human", mitoIDType = "symbol", 
                 mitoGeneLocation = "rownames", seed = 12345)

sce <- runQuickUMAP(sce, reducedDimName = "QC_UMAP", seed = 12345)
```

>**Note:** If you have cells from multiple samples stored in the SCE object, make sure to supply the `sample` parameter as the QC tools need to be applied to cells from each sample individually.

**Visualization**

Individual sets of QC metrics can be plotted with specific functions. For example to plot distributions of total numbers of UMIs derived from `runPerCellQC()`, doublet scores from `runScDblFinder()`, and contamination scores from `runDecontX()` (all of which were run by the `runCellQC()` function), the following plotting functions can be used:

```{R plotPerCellQC, message=FALSE, warning=FALSE, fig.height=10, fig.width=8}
plotRunPerCellQCResults(sce)
```

```{R plotScDblFinder, message=FALSE, warning=FALSE, fig.height=7, fig.width=8}
plotScDblFinderResults(sce, reducedDimName = "QC_UMAP")
```

```{R plottDecontX, message=FALSE, warning=FALSE, fig.height=7, fig.width=8}
plotDecontXResults(sce, reducedDimName = "QC_UMAP")
```

A comprehensive HTML report can be generated to visualize and explore the QC metrics in greater detail:

```{R reportqc, eval=FALSE}
reportCellQC(sce)
```

Please find [the detailed documentation for running QC functions](cnsl_cellqc.html) for detail.

````{=html}
</div>
</div>
````

Besides the approaches described above, we have also published the SCTK-QC pipeline [@Rui2022]. Please refer to the [SCTK-QC Documentation](cmd_qc.html) for detail. 

## Filtering

After examining the distributions of various QC metrics, poor quality cells will need to be removed. Typically, thresholds for QC metrics should exclude cells that are outliers of the distribution (i.e. long tails in the violin or density plots). Here is how we limit the data to cells with 1. at least 600 counts, 2. at least 300 genes detected, and 3. at most 5% of detected counts are mitochondrial. For more detail about filtering, please refer to the [Filtering documentation](filtering.html)

````{=html}
<!--Remember to change tabset id-->
<div class="tabset" id="tabset3">
<div class="tab">
  <!--Remember to change tabset id argument of `openTab`-->
  <button class="tablinks ia" onclick="openTab(event, 'ia', 'tabset3')">Interactive Analysis</button>
  <button class="tablinks console" onclick="openTab(event, 'console', 'tabset3')">Console Analysis</button>
</div>

<div class="tabcontent ia">
````

![import](ui_screenshots/ui_tutorial/filter_enter.png)\

1. Enter the filtering section by clicking on sub-tab **"Filtering"**.

![import](ui_screenshots/ui_tutorial/filter_add.png)\

2. Click on button **"Add a Filter"** in the first grey panel **"Select Cell Filtering Criteria"**.
3. In the pop up, select one of the cell metadata variables that stands for the QC metrics. It should be `total`, `detected` and `mito_percent` for each criteria. 
4. Set the cut-off for each criteria. If you want to keep cells with value `total` greater than 600, you would check **"Greater than"**, and enter the number `600`. Similarly, if you want to keep cells with value `mito_percent` less than 5, you would check **"Less than"** and enter the number `5`. 
5. For every criteria, after entering the cut-off, click on button **OK** to add the filter "to the cart". 
6. Repeat step 2-5 to add the three filters. After each criteria is added, you can see a new row inserted to the table, as shown in the dashed box in the screenshot below. 

![import](ui_screenshots/ui_tutorial/filter_run.png)\

7. Finally, click on **"Filter"** button at the bottom of the current view to apply all filters at one time. 

![import](ui_screenshots/ui_tutorial/filter_summary.png)\

After successfully filtering the data, you can see a comparison table shows up at the bottom. You can apply new filters by repeating the steps above, but it will only be applied on the filtered data instead of the original data. 

````{=html}
</div>
<div class="tabcontent console">
````

Cells can be removed using the `subsetSCECols()` function. Metrics stored in the `colData` slot of the SCE object can be filtered using the `colData` parameter.

```{R filter}
# See number of cells before filtering
ncol(sce)
sce <- subsetSCECols(sce, colData = c("total > 600", 
                                      "detected > 300",
                                      "mito_percent < 5"))

# See number of cells after filtering
ncol(sce)
```

````{=html}
</div>
</div>
````

```{R output, include=FALSE}
saveRDS(sce, "tutorial_pbmc3k_qc.rds")
```



## Introduction

Single Cell Toolkit (singleCellTK, SCTK) is a package that works on single-cell RNA-seq (scRNAseq) dataset. SCTK allows users to import multiple datasets, perform quality control and a series of preprocessing, get clustering on cells and markers of clusters, and run various downstream analysis. Meanwhile, SCTK also wraps curated workflows for [celda](https://www.camplab.net/celda/) and [Seurat](https://satijalab.org/seurat/).

This tutorial takes the real-world scRNAseq dataset as an example, which consists of 2,700 Peripheral Blood Mononuclear Cells (PBMCs) collected from a healthy donor, namingly PBMC3K. This dataset is available from 10X Genomics and can be found on the 10X website.

Before heading into the next steps, we assume that users have already loaded SCTK, imported and QC'ed the PBMC3K data, following the [Import and QC Tutorial](01_import_and_qc_tutorial.html).

## Normalization {#normalization}

After removing cells of low quality, we next need to normalize the feature expression matrix. In this tutorial, we apply a global-scaling normalization method from [scater](https://bioconductor.org/packages/release/bioc/html/scater.html), `"logNormCounts"`. It normalizes the feature expression for each cell by the total expression, multiplies this by a scale factor, and log-transforms the result.

For detail about all normalization methods, please refer to the [Normalization Documentation](normalization.html)

```{=html}
<!--Remember to change tabset id-->
<div class="tabset" id="tabset1">
<div class="tab">
  <!--Remember to change tabset id argument of `openTab`-->
  <button class="tablinks ia" onclick="openTab(event, 'ia', 'tabset1')">Interactive Analysis</button>
  <button class="tablinks console" onclick="openTab(event, 'console', 'tabset1')">Console Analysis</button>
</div>

<div class="tabcontent ia">
```
![norm](ui_screenshots/ui_tutorial/norm.png)\

1.  Users should enter the section for normalization from the **"Normalization & Batch Correction"** tab at the top navigation panel.
2.  In the **"Normalization"** sub-tab, choose the method `"Scater - LogNormCounts"` from the left panel.
3.  Users can directly press the **"Run"** button at the bottom right without taking any more action.

```{=html}
</div>
<div class="tabcontent console">
```
SCTK has a generic wrapper function for various types of normalization, called `runNormalization()`.

```{R norm, results='hold'}
sce <- runNormalization(sce, useAssay = "counts", outAssayName = "logcounts",
                        normalizationMethod = "logNormCounts")
```

```{=html}
</div>
</div>
```
SCTK also supports a number of batch correction methods. Here we don't present the workflow because PBMC3k dataset only has one batch. For examples, please refer to the [document of batch correction](batch_correction.html).

We also recommend performing the scaling method to standardize the variance, and this results in a better PCA. The UI and console function allow users to perform scaling on the expression assay. However, we don't recommend directly apply this to the full-sized expression matrix because the memory usage will be large. To accomplish this, we suggest finding the highly variable genes first in the next section, and only scaling the subset of the expression matrix as instructed.

## Variable Feature Selection

Selecting highly variable genes (HVG) for downstream analyses is recommended, since a subset of variable features enhances the biological signal for community detection and reduces amount of data being used which hence speeds up the computation. SCTK wraps the methods used in [Seurat](https://satijalab.org/seurat/) and [Scran](https://bioconductor.org/packages/release/bioc/html/scran.html). We recommend keeping at least 2,000-5,000 HVGs. In this tutorial, we use the "modelGeneVar" method from Scarn, and select the top 2,000 genes.

SCTK requires at least two steps to create the HVG subset. The first step performs variability calculation and stores the metrics, and the second step selects top genes basing on the ranking of the metrics.

```{=html}
<!--Remember to change tabset id-->
<div class="tabset" id="tabset2">
<div class="tab">
  <!--Remember to change 2 tabset id arguments of `openTab`-->
  <button class="tablinks ia" onclick="openTab(event, 'ia', 'tabset2')">Interactive Analysis</button>
  <button class="tablinks console" onclick="openTab(event, 'console', 'tabset2')">Console Analysis</button>
</div>

<div class="tabcontent ia">
```
![hvg1](ui_screenshots/ui_tutorial/hvg1.png)\

1.  Users should enter the feature selection tab from the top navigation bar as instructed in the screenshot. And then the **"Feature Selection"** sub-tab.
2.  For the first step, in the top-left panel **"1. Compute variability metric"**, select the method via **"Select method for calculating variability of features"**. The assay to be used will be automatically updated on selection, since different method has different recommended assay type.
3.  Click on button **"Run"** to calculate the variability.

After calculation, the panel for selecting the top features, **"2. Select number of variable features"** becomes enabled. A scatter plot of features, with axes of variance and mean, will also be shown on the right panel **"Plot"**.

![hvg2](ui_screenshots/ui_tutorial/hvg2.png)\

4.  In the bottom-left panel **"2. Select number of variable features"**, users now only need to click on the button **"Run"** to finish the selection for this tutorial.

After selection, the plot will be again updated, with highlighted red dots representing the selected features, texts labeling a smaller number (adjustable in the dropdown) of features with the top variability among the selected ones. The names of highlighted features are also updated in a text box at the bottom of the plotting region.

Note that:

-   The metrics to be used for selection will only be available after calculation in the first panel.
-   In the dropdown box at the top of the plotting region, users can choose to label the selected subset on a different metric scatter plot.
-   When analyzing users' own data, if the text labels of features being shown are Ensembl IDs (i.e. starts with things like "ENSG000"), users can change the display ID type with **"Choose feature label"**. This works only when the annotation is available in imported feature metadata. We strongly recommend users go back to the **"Data" -\> "Import Single Cell Data"** page, scroll down to the bottom, and set the display ID type at **"Set feature names to be displayed in downstream visualization"**, so the change works globally through out SCTK.

```{=html}
</div>
<div class="tabcontent console">
```
For calculating the feature variablity, users can use either the wrapper function of each method (`runSeuratFindHVG()`, `runModelGeneVar()`) or using the generic wrapper `runFeatureSelection()` with argument `method` specified.

```{R hvg}
sce <- runModelGeneVar(sce, useAssay = "logcounts")
sce <- setTopHVG(sce, method = "modelGeneVar", hvgNumber = 2000, featureSubsetName = "hvg2000")
```

Users can also get the character vector of gene names:

```{R getTopHVG}
hvg <- getTopHVG(sce, useFeatureSubset = "hvg2000")
print(hvg[1:10])
```

The variability metrics and the top variable feature selection can also be visualized:

```{R plotTopHVG}
plotTopHVG(sce, method = "modelGeneVar", hvgNumber = 2000, labelsCount = 10)
```

```{=html}
</div>
</div>
```
## Dimension Reduction

The next step is performing a principal component analysis (PCA), which creates new uncorrelated variables that successively maximize variance and finally increases the data interpretability and at the same time minimizes the information loss.

With the HVG selected from the previous step, we will perform PCA using the method from [Scater](http://bioconductor.org/packages/release/bioc/html/scater.html). As mentioned in the [Normalization section](#normalization), we will also have the selected HVG scaled in this step.

SCTK also supports Seurat's PCA and ICA method, which do a similar job. Please see: [Seurat Curated Workflow](seurat_curated_workflow.html), and [Dimension Reduction Documentation](dimensionality_reduction.html).

```{=html}
<!--Remember to change tabset id-->
<div class="tabset" id="tabset3">
<div class="tab">
  <!--Remember to change tabset id argument of `openTab`-->
  <button class="tablinks ia" onclick="openTab(event, 'ia', 'tabset3')">Interactive Analysis</button>
  <button class="tablinks console" onclick="openTab(event, 'console', 'tabset3')">Console Analysis</button>
</div>

<div class="tabcontent ia">
```
![pca_entry](ui_screenshots/ui_tutorial/pca_entry.png)\

1.  Enter the main tab as instructed in the screenshot above. If users are following the previous steps in this tutorial, then we are already here.
2.  Enter the sub-tab for dimension reduction via **"Dimensionality Reduction"**

![pca_entry](ui_screenshots/ui_tutorial/pca_param.png)\

3.  All of the parameters have been automatically updated for the most commonly seen scenario. Users can directly click on button **"Run"** for this tutorial.

What we actually set for the parameters:

-   Use the log-transformed normalized counts as the input
-   Subset features basing on the selection in the previous section
-   opt to scale the feature subset

Besides the scatter plot of the top two components for all cells, the switches also add an elbow plot and heatmap for visualization

![pca_entry](ui_screenshots/ui_tutorial/pca_plots.png)\

After running, the plots will be updated on the right side. The elbow plot and heatmaps are internally calculated by Seurat functions.

The elbow plot is a heuristic method for determining the dimensionality to be used for downstream analysis. It is a ranking of principle components based on the percentage of variance explained by each one. In this example, we can observe an "elbow" around PC9-10, suggesting that the majority of true signal is captured in the first 10 PCs.

The heatmap allows for easy exploration of the primary sources of heterogeneity in a dataset, and can be useful when trying to decide which PCs to include for further downstream analyses. Both cells and features are ordered according to their PCA scores. Please refer to [Seurat's tutorial](https://satijalab.org/seurat/articles/pbmc3k_tutorial.html#perform-linear-dimensional-reduction-1) for more explanation on these two visualization approaches.

```{=html}
</div>
<div class="tabcontent console">
```
Here we use the wrapper function `scaterPCA()`. The name of transformed normalized expression matrix can be passed to `useAssay` (by default `useAssay = "logcounts"`), and the name of the HVG subset should be passed to `useFeatureSubset`. The scaling will be done by Scater by setting `scale = TRUE` (default). The output PCs will be updated in the `reducedDims` slot of the SCE object, named by `"PCA"` by default.

```{R pca}
sce <- scaterPCA(sce, useFeatureSubset = "hvg2000", seed = 12345)
```

Afterwards, users can make scatter plots to visualize the top dimensions that explains the most variance of the original data:

```{R plotPCA}
plotDimRed(sce, useReduction = "PCA")
```

```{=html}
</div>
</div>
```
## 2D Embedding

Uniform Manifold Approximation and Projection (UMAP) and t-distributed Stochastic Neighbor Embedding (tSNE) are the most commonly used methods to visualize the relationships between the cells in a 2-D embedding. UMAP gives a better presentation of the global structure and is more efficient, while tSNE performs better in preserving the local structure.

In this tutorial, we calculate a UMAP embedding from the principal components generated in the previous step. We will use only 10 dimensions out of the 50 dimensions generated.

```{=html}
<!--Remember to change tabset id-->
<div class="tabset" id="tabset4">
<div class="tab">
  <!--Remember to change tabset id argument of `openTab`-->
  <button class="tablinks ia" onclick="openTab(event, 'ia', 'tabset4')">Interactive Analysis</button>
  <button class="tablinks console" onclick="openTab(event, 'console', 'tabset4')">Console Analysis</button>
</div>

<div class="tabcontent ia">
```
![umap_entry](ui_screenshots/ui_tutorial/umap_entry.png)\

1.  Users should be at the same main tab as performing dimension reduction with PCA.
2.  Click on the last sub-tab **"Embedding"** to access the functionality for this section.

![umap_run](ui_screenshots/ui_tutorial/umap_run.png)\

3.  Select the name of the PCA matrix we generated in the previous section, from the selection input **"Select Input Matrix"**.
4.  While users feel reasonable with other parameters, users can click on button **"Run"** to start the UMAP calculation.

After done, a scatter plot of all cells on the UMAP dimension will be shown on the right panel.

```{=html}
</div>
<div class="tabcontent console">
```
A UMAP can be generated with the function `runUMAP()`, which is a wrapper of `calculateUMAP()` method in the `scater` package. We will now use `useReducedDim` argument to pass the PCA embedding just generated to the function. The result will be saved in `reducedDim` slot.

Users can also create the tSNE embedding with `runTSNE()` function, which works in a similar way as `runUMAP()`

```{R UMAP, results="hold"}
sce <- runUMAP(sce, initialDims = 10, seed = 12345)
```

```{R plotUMAP}
plotDimRed(sce, useReduction = "UMAP")
```

Note that we have another two functions `runQuickUMAP()` and `runQuickTSNE()`, which wrap the two functions mentioned above, respectively, and run directly from raw count matrix with all steps in the workflow automated internally. They can help with fast visualization at the beginning of an analysis.

```{=html}
</div>
</div>
```
## Clustering {#clustering}

SCTK supports clustering cells with Shared Nearest Neighbors (SNN) graph based methods and K-Means algorithm. For SNN graph based methods, we wrap the graph constructor from `scran` library, and have options of algorithms from `igraph` that can perform clustering on the graph. Alternatively, in the [Seurat Curated Workflow](seurat_curated_workflow.html), the Seurat's SNN graph construction and community detection method are also wrapped as one method.

In this tutorial, we use the scran SNN graph approach, with the community detection algorithm set as Louvain. We will use the top 10 components for identifying the clusters. Though we have generated the UMAP representation in the previous section (also using 10 PCs), users are always allowed to test clustering with different numbers of PCs. In this case, we strongly suggest regenerating the UMAP with the consistent number of PCs, so that the UMAP can best reflect the information included in the PCs.

For the scran SNN graph approach, the parameter `k` can always be tweaked as it affects the connectivity of the graph. When `k` is larger, stronger connection will be constructed across the cells, thus larger and fewer clusters will be identified. Parameter `weightType` allows for different shared neighbor weighting schemes. In this tutorial, we use `"jaccard"` as it provides consistency with Seurat methods.

```{=html}
<!--Remember to change tabset id-->
<div class="tabset" id="tabset5">
<div class="tab">
  <!--Remember to change tabset id argument of `openTab`-->
  <button class="tablinks ia" onclick="openTab(event, 'ia', 'tabset5')">Interactive Analysis</button>
  <button class="tablinks console" onclick="openTab(event, 'console', 'tabset5')">Console Analysis</button>
</div>

<div class="tabcontent ia">
```
![cluster_entry](ui_screenshots/ui_tutorial/cluster_entry.png)\

1.  Users should enter the clustering tab via the top navigation bar as instructed in the screenshot above.

![cluster_run](ui_screenshots/ui_tutorial/cluster_run.png)\

2.  Select the same PCA matrix as we've done in the 2D Embedding section, at the selection input **"Select Input Matrix"**
3.  Tweak the parameters as we described in the introduction of this section.
4.  Click on button **"Run"** to start clustering the data.

Upon completing clustering, a scatter plot of cells on a low-dimensional representation with cluster labeling colored on each cell will be shown on the right. However, we use the dimensions used for calculation as the default. For the best visualization, we suggest users change the dimensions to the 2D embedding obtained from the same components (of the same PCA matrix) as used for clustering.

5.  In the dropdown panel of the plotting region, select the UMAP we previously generated from **"Use Reduction"**, and then click on button **"Update"**.

```{=html}
</div>
<div class="tabcontent console">
```
With `runScranSNN()` function, the dimension reduction matrix can be specified through argument `useReducedDim`, and the cluster label assignment will be updated in the `colData` slot, and the variable will be named by argument `clusterName`. The default graph clustering algorithm is Louvain, while we also provide options including Leiden, Walktrap and etc. (from `igraph`).

```{R cluster, results="hold"}
sce <- runScranSNN(sce, "PCA", clusterName = "cluster", nComp = 10,
                   weightType = "jaccard", k = 14, seed = 12345)
```

After getting the cluster labeling, we can then visualize it:

```{R plotCluster}
plotSCEDimReduceColData(sce, "cluster", "UMAP")
```

```{=html}
</div>
</div>
```
In the other curated workflow that SCTK wraps ([Celda Curated Workflow](celda_curated_workflow.html)), we use a Bayesian hierarchical model that can bi-cluster features into modules and observations into subpopulations. For detail of this method, please refer to the [Celda Documentation](https://www.camplab.net/celda/).

```{r export_cluster, include=FALSE}
saveRDS(sce, "tutorial_pbmc3k_clustered.rds")
```

## Marker Detection

Users can next perform marker detection process with the cluster labels, or any other types of reasonable grouping of similar biological state of cells stored in the cell metadata. SCTK iteratively finds markers for each cluster by running differential expression (DE) analysis on the cluster against all the other clusters.

Although we selected the variable features and reduced the dimensionality of the original expression matrix, here we will get back to the transformed normalized counts of all features.

```{=html}
<!--Remember to change tabset id-->
<div class="tabset" id="tabset6">
<div class="tab">
  <!--Remember to change tabset id argument of `openTab`-->
  <button class="tablinks ia" onclick="openTab(event, 'ia', 'tabset6')">Interactive Analysis</button>
  <button class="tablinks console" onclick="openTab(event, 'console', 'tabset6')">Console Analysis</button>
</div>

<div class="tabcontent ia">
```
![marker_entry](ui_screenshots/ui_tutorial/marker_entry.png)\

1.  Click on the **"Differential Expression & Cell Type Labeling"** tab at the top navigation bar.
2.  In the dropdown, click **"Find Marker"** to enter this tab, as instructed in the screenshot above.

![marker_run](ui_screenshots/ui_tutorial/marker_run.png)\

3.  Users need to check if the proper log-normalized assay data is chosen at selection **"Select assay"**. SCTK usually push a recommended one to the top, but sometimes alternatives of the same type can be in the place. Also, users need to select the cluster label variable at selection **"Cluster Annotation"**.
4.  Click on **"Run"** button to start the analysis.

After the analysis is done, the result would be presented in the right main panel, with a marker heatmap and the table of statistical metrics. Users can tweak the displaying parameters of each through the dropdown menu or filter module, respectively.

```{=html}
</div>
<div class="tabcontent console">
```
```{R findMarker, message=FALSE, warning=FALSE, results="hold"}
sce <- runFindMarker(sce, useAssay = "logcounts", method = "wilcox", cluster = "cluster")
```

By running `runFindMarker()`, SCTK stores a `data.frame` of marker table to the `matadata` slot of the SCE object. The marker table will include all detected markers for each cluster and statistical values associated to each marker. To fetch the table, users can use the command below, and even add filtering parameters.

```{R getMarkerTable, results="hold"}
topMarkers <- getFindMarkerTopTable(sce, topN = 1, log2fcThreshold = 0, 
                                    fdrThreshold = 0.05, minClustExprPerc = 0.5, 
                                    maxCtrlExprPerc = 0.5, minMeanExpr = 0)
topMarkers
```

For visualization, SCTK has a specific heatmap plotting function for detected markers. The heatmap will take the log-normalized feature expression matrix for the values (scaled when plotting), and subset the features to only the top markers of each cluster. For the organization of the heatmap, the function groups the markers by the belonging to the clusters, and groups the cells, obviously, by clusters.

```{R markerHeatmap, results="hold", fig.height= 8, fig.width=9}
plotFindMarkerHeatmap(sce, topN = 5, log2fcThreshold = 0.5, 
                      fdrThreshold = 0.05, minClustExprPerc = 0.5, 
                      maxCtrlExprPerc = 0.5, minMeanExpr = 0, 
                      rowLabel = TRUE)
```

```{=html}
</div>
</div>
```
As we can observe from the marker heatmaps above, most of the clusters can be easily differentiated by the top marker genes of each cluster. However, "cluster 1" and "cluster 2"are seemingly having less difference between each other than compared to other cell clusters, in terms of the marker genes presented in the heatmap (top 5 markers for each cluster). To further explore the differential expression between them, we could do a cluster-by-cluster DE analysis in the next section.

## Differential Expression Analysis {#differential-expression-analysis}

Beyond finding the markers for each cluster, usually people are also interested in the differential expression between specific clusters and even groups of clusters. SCTK provides a relatively flexible way for conducting such analysis.

There are multiple ways to specify the groups of cells to be compared: by either directly specifying indices of cells, or selecting groups of cells with a categorical variable annotated in the cell metadata. However, when running DE analysis, SCTK requires a relatively sophisticated inputs for naming the analyses, including the names of the two groups, and the name of one analysis, though these are not necessary for calling the algorithms alone. By requiring these, the results of the analyses can be stored with human readable identifiers and within one single data container (SCE object), and can be more manageable. See the [DE documentation](differential_expression.html) for the detail.

Continued from the previous section, we will now set "cluster 1" and "cluster 2" as the two groups to perform the analysis.

```{=html}
<!--Remember to change tabset id-->
<div class="tabset" id="tabset7">
<div class="tab">
  <!--Remember to change tabset id argument of `openTab`-->
  <button class="tablinks ia" onclick="openTab(event, 'ia', 'tabset7')">Interactive Analysis</button>
  <button class="tablinks console" onclick="openTab(event, 'console', 'tabset7')">Console Analysis</button>
</div>

<div class="tabcontent ia">
```
![de_entry](ui_screenshots/ui_tutorial/de_entry.png)\
![de_run](ui_screenshots/ui_tutorial/de_run.png)\

1.  Click on the **"Differential Expression & Cell Type Labeling"** tab at the top navigation bar, and then click on **"Differential Expression"** to enter the tab
2.  At the first section, check for the log-normalized assay to use for the DE test, at selection **"Select assay"**.
3.  Name the two groups involved in an single analysis.
4.  In this tutorial, we set the condition by using a categorical cell metadata (as selecting "By annotations" at the top). Now users will need to select the variable that stands for the cluster labeling, as selection **"Choose Annotation Class"**
5.  After setting the cluster variable, users can now choose the cluster(s) for each condition. Multiple selection for each condition is enabled in case users want to perform the DE analysis on any alternative grouping.
6.  Name this single analysis. This is required for SCTK to clearly store and present the results of multiple analyses.
7.  Finally, click on **"Run"** to start the DE analysis.

After running, The visualization section at the bottom of this tab will be automatically updated. SCTK provides a heatmap, a table of statistic metrics, a volcano plot, a violin plot and a regression plot for visualization. Users can tweak the display option through the dropdown menu of a plot or the filtering module of the table.

![de_vis](ui_screenshots/ui_tutorial/de_vis.png)\

```{=html}
</div>
<div class="tabcontent console">
```
`runDEAnalysis()` is a generic function for performing differential expression (DE) analysis between two selected groups of cells. This is also used by `runFindMarker()`. By running DE analysis, the function will take the expression assay with all features and perform statistical analysis to discover quantitative changes in expression levels between selected groups.

```{R de, results="hold"}
sce <- runDEAnalysis(inSCE = sce, method = "wilcox", useAssay = "logcounts",
                     class = "cluster", classGroup1 = c(1), classGroup2 = c(2),
                     groupName1 = "cluster1", groupName2 = "cluster2", 
                     analysisName = "cluster1_VS_2")
```

Similarly to the marker detection section, SCTK also has a DE analysis specific heatmap plotting function, `plotDEGHeatmap()`. Here, users can just easily enter the `analysisName` specified for one run and the function will automatically arrange the output. The heatmap is also splitted into a "checker board", by the "conditions" (i.e. the groups selected when running `runDEAnalysis()`) and the "regulation" (i.e. "up" if the log2 fold change is positive in "group1" against "group2").

```{R deHeatmap, message=FALSE, warning=FALSE, results="hold", fig.height=7}
plotDEGHeatmap(sce, useResult = "cluster1_VS_2", log2fcThreshold = 0.3, rowLabel = TRUE)
```

```{=html}
</div>
</div>
```
Besides using a feature expression assay for DE analysis, SCTK also allows using matrices stored in the low-dimensional representation slot of the data container (`useReducedDim` argument of `runDEAnalysis()`). For example, when users perform a pathway analysis and get a score matrix (stored in `reducedDims` slot), DE analysis can be performed on this score matrix. See [example](#performing-de-analysis-on-pathway-analysis-scores).

## Cell Type Labeling {#cell-type-labeling}

SCTK adopts [SingleR](https://bioconductor.org/packages/release/bioc/html/SingleR.html) method for labeling the cell types. Briefly, this method labels each cell (or cluster) in users' datasets basing on similarity to a reference datasets. SingleR has recommended some datasets, so we enable quick loading of these references. Please see [Cell Type Labeling Documentation](cell_type_labeling.html) for detail.

Choosing a reference from the recommended builtin references would also require some prior knowledge of user data. **Users should choose a reference that covers the cell types possibly existing in the user dataset**. SingleR works by scoring the similarity to each cell type and assigning a cell type by the highest score, regardless of how low the score is. A beta cell from pancreas data could even be wrongly labeled as a platelet if using a blood cell reference.

```{=html}
<!--Remember to change tabset id-->
<div class="tabset" id="tabset8">
<div class="tab">
  <!--Remember to change tabset id argument of `openTab`-->
  <button class="tablinks ia" onclick="openTab(event, 'ia', 'tabset8')">Interactive Analysis</button>
  <button class="tablinks console" onclick="openTab(event, 'console', 'tabset8')">Console Analysis</button>
</div>

<div class="tabcontent ia">
```
![celltype_entry](ui_screenshots/ui_tutorial/celltype_entry.png)\
![celltype_run](ui_screenshots/ui_tutorial/celltype_run.png)\

1.  Click on the **"Differential Expression & Cell Type Labeling"** tab at the top navigation bar, and then click on **"Cell Type Labeling"** to enter the tab.
2.  Though this is optional, users could change the labeling level from "main" to "fine" at selection **"Labeling level"**. This option refers to what cell type annotation in the reference dataset the user dataset should be mapped to. It is also important to check the option **"Feature type"**, which asks for the default feature ID type.
3.  Users can click on **"Run"** to start the labeling at this point.

Users can visualize the labeling via a UMAP, by going back to the [clustering tab](#clustering).

![celltype_vis](ui_screenshots/ui_tutorial/celltype_vis.png)\

4.  In the right main visualization panel of the clustering tab, choose **"Select from All Present Annotation"**.
5.  Select the variable that SingleR just produced. There will be three types of labeling, ending with `first.labels`, `labels` or `pruned.labels`.
6.  Click on **"Update"** to show the SingleR labels on the UMAP

```{=html}
</div>
<div class="tabcontent console">
```
The recommended reference can be chosen by specifying the abbreviation name of them in argument `useBltinRef`. Please click on the function name for usage detail.

```{R singleR, results="hold"}
sce <- runSingleR(sce, useAssay = "logcounts", level = "fine")
```

The result of labeling will again be saved to `colData` slot of the SCE object. There will be multiple types of information being stored, including a scoring matrix named by `"SingleR_{ref}_{level}_scores"`, where `{ref}` refers to the reference selected, `{level}` refers to the `level` argument being passed to the function. And three `"SingleR_{ref}_{level}_{typeOfLabels}"` columns, where `{typeOfLabels}` includes `first.labels`, `labels`, `pruned.labels`. For the difference, please refer to `?SingleR::classifySingleR`.

We can also plot the labeling on to the UMAP we got previously.

```{R singleRUMAP, message=FALSE, warning=FALSE, fig.width=12}
plotSCEDimReduceColData(sce, colorBy = "SingleR_hpca_fine_pruned.labels",
                        reducedDimName = "UMAP")
```

```{=html}
</div>
</div>
```
## Differential Abundance

The goal of the differential abundance analysis is to determine if categorical variables such as phenotype or sample (e.g. treatment or control) are enriched in different cell clusters using the Fisher's exact test (FET). Any categorical variables in `colData(sce)` can be used by passing the variable name to argument `cluster` or `variable`. Categories in the phenotype variable (used for `variable`) can be passed to `case` or `control`. For this example, we try to examine whether there are any [cell clusters](#clustering) enriched in an annotated cell type [using SingleR](#cell-type-labeling).

```{R diffAbundance, fig.width=10}
# Returns a vector where TRUE for a type of NK cell
isNKCell <- startsWith(colData(sce)$SingleR_hpca_fine_pruned.labels, "NK_cell")
# Returns a vector where TRUE for a type of T cell
isTCell <- startsWith(colData(sce)$SingleR_hpca_fine_pruned.labels, "T_cell")
# Make up a variable with only categories of "NK_cell", "T_cell" and "Other".
colData(sce)$cell_type <- ifelse(isNKCell, "NK_cell", "Other")
colData(sce)$cell_type[isTCell] <- "T_cell"
colData(sce)$cell_type[is.na(colData(sce)$cell_type)] <- "Other"
# Run differential abundance test
sce <- diffAbundanceFET(sce, cluster = "cluster", 
                        variable = "cell_type", 
                        case = "NK_cell", control = "T_cell",
                        analysisName = "NK_VS_T")
```

Users can get the table of result with the method below, using the `analysisName` specified when running the analysis.

```{R getDiffAbundanceCode, eval=FALSE}
getDiffAbundanceResults(sce, analysisName = "NK_VS_T")
```

```{R getDiffAbundanceShow, echo=FALSE}
res <- getDiffAbundanceResults(sce, analysisName = "NK_VS_T")
knitr::kable(format(res, digits = 3))
```

Alternatively, users can choose to directly make a plot using the two variables and the function `plotClusterAbundance()` will automatically calculate the statistic and visualize the result. The proportion or count of each category in each cluster will be displayed in stacked bar plots:

```{R plotClusterAbundance, fig.height=7}
plotClusterAbundance(sce, cluster = "cluster", variable = "cell_type")
```

## Pathway Analysis

For the purpose of gene set enrichment (GSE) analysis, SCTK imports VAM and GSVA as options. Both of them work by loading some user-defined gene sets ([more about loading gene sets](import_genesets.html)), and calculating the enrichment score of each gene set in each cell. Here we will go through calling VAM to inspect the enrichment of the hallmark gene sets available in [MSigDB database](https://www.gsea-msigdb.org/gsea/msigdb/). Please refer to the [document](pathwayAnalysis.html) for the detail of running pathway analysis with VAM or GSVA.

SCTK also supports GSEA method from EnrichR, which queries a given gene list and finds the significant overlap against the curated gene sets from multiple gene set libraries. For detail, please refer to [EnrichR Documentation](enrichR.html).

```{=html}
<!--Remember to change tabset id-->
<div class="tabset" id="tabset10">
<div class="tab">
  <!--Remember to change tabset id argument of `openTab`-->
  <button class="tablinks ia" onclick="openTab(event, 'ia', 'tabset10')">Interactive Analysis</button>
  <button class="tablinks console" onclick="openTab(event, 'console', 'tabset10')">Console Analysis</button>
</div>

<div class="tabcontent ia">
```
![pathway_entry](ui_screenshots/ui_tutorial/pathway_entry.png)\
![pathway_run](ui_screenshots/ui_tutorial/pathway_run.png)\

1.  Click on the **"Enrichment & Pathway Analysis"** tab at the top navigation bar, and then click on **"Pathway Activity"** to enter the tab.
2.  Select the assay to be used for the pathway analysis at the selection **"Select assay"**. A log-normalized assay is recommended.
3.  Select a gene set collection of interest at the selection **"Select Geneset Collection"**. If no option is available here, users can click on the link **"Import Gene Sets"** next to it to be prompt to the tab for importing gene set. (See documentation for [how to import gene sets](import_genesets.html))
4.  Click on **"Run"** button to start the analysis.

After finished, a violin plot will be shown in the right main panel. By default, SCTK shows scores in all cells for the first gene set in the selected collection, in a single violin plot. With options in the dropdown menu, users can choose to shown the scores of a different gene set at seletion **"Select Geneset"**, or group the scores by the cluster labels by choosing the cluster variable at the selection **"Select condition of interest to group data"**. After tweaking the options, click on button **"Update Plot"** to apply the changes.

```{=html}
</div>
<div class="tabcontent console">
```
```{R VAM}
sce <- importGeneSetsFromMSigDB(sce, categoryIDs = "H", species = "Homo sapiens")
sce <- runVAM(sce, geneSetCollectionName = "H", useAssay = "logcounts")
```

To visualize the result, we simply adopt a violin plot to show the distribution of the CDF scores of the cells, which can be, optionally, grouped by the cluster labels.

```{R visVAM}
hallmark <- "HALLMARK_INFLAMMATORY_RESPONSE"
plotPathway(sce, resultName = "VAM_H_CDF", geneset = hallmark, groupBy = "cluster")
```

Note that available options for argument `resultName` and `geneset` can be printed with getter functions below.

```{R pathwayGetter, eval=FALSE}
getPathwayResultNames(sce)
getGenesetNamesFromCollection(sce, geneSetCollectionName = "H")
```

> Note: In the current version of SCTK, the returned score matrices from either VAM or GSVA are stored in the `reducedDims` slot, since the feature dimensions are for the gene sets instead of the genes or subsets of genes. In the future, SCTK will adopt other types of data container for simpler operation on different types of feature sets.

```{=html}
</div>
</div>
```
### Performing DE Analysis on Pathway Analysis Scores {#performing-de-analysis-on-pathway-analysis-scores}

SCTK allows users to select the score matrix from pathway analysis to perform differential expression analysis. In this process, each geneset will be treated as the feature, and comparison groups can still be set in the same way as introduced in [DE analysis section](#differential-expression-analysis).

```{=html}
<!--Remember to change tabset id-->
<div class="tabset" id="tabset11">
<div class="tab">
  <!--Remember to change tabset id argument of `openTab`-->
  <button class="tablinks ia" onclick="openTab(event, 'ia', 'tabset11')">Interactive Analysis</button>
  <button class="tablinks console" onclick="openTab(event, 'console', 'tabset11')">Console Analysis</button>
</div>

<div class="tabcontent ia">
```
Please refer to the [DE analysis section](#differential-expression-analysis) for how to reach the tab for performing DE analysis.

![pathway_de](ui_screenshots/ui_tutorial/pathway_de.png)\

1.  At the selection **"Select assay"**, scroll down and find the section called "redDims". From here, select the matrix for the VAM score.
2.  Enter the analysis settings as introduced before.
3.  Click on button **"Run"**.

The same result presentation methods will be shown at the bottom of this tab. Users might need to check the console log message at this point if the heatmap is not shown. The default log2 fold-change cutoff works for the log-normalized gene expression value, and is usually too high for the pathway analysis score to keep any gene sets. Therefore, we recommend users to open the dropdown menu and set the log2 fold-change cutoff to a value around `0.03` to update the heatmap.

```{=html}
</div>
<div class="tabcontent console">
```
To run DE analysis with matrix in the `reducedDims` slot, users only need to simply specify the matrix name to argument `useReducedDim` (`useAssay` will be ignored in this case).

```{R pathwayDE}
sce <- runDEAnalysis(inSCE = sce, method = "wilcox", useReducedDim = "VAM_H_CDF",
                     class = "cluster", classGroup1 = c(1, 2, 5), classGroup2 = c(3, 6),
                     groupName1 = "T_cells", groupName2 = "monocytes", 
                     analysisName = "T_cells_VS_monocytes_VAM_H_CDF", overwrite=T)
```

As the nature of the pathway analysis score is different from a log-normalized gene expression value, the default cutoff for log2 fold-change is likely to rule out all gene sets in this case. Therefore, we need to manually set a rather small value for this cutoff.

```{R pathwayDEHeatmap, fig.height=9, fig.width=9}
plotDEGHeatmap(sce, useResult = "T_cells_VS_monocytes_VAM_H_CDF", rowTitle = "Geneset", log2fcThreshold = 0.05)
```

````{=html}
<script>
var ia_contents = document.getElementsByClassName("tabcontent ia")
for (var i = 0; i < ia_contents.length; i++){
    ia_contents[i].style.display = "block";
}
var cnsl_contents = document.getElementsByClassName("tabcontent console")
for (var i = 0; i < cnsl_contents.length; i++){
    cnsl_contents[i].style.display = "none";
}
var ia_buttons = document.getElementsByClassName("tablinks ia")
for (var i = 0; i < ia_buttons.length; i++){
    ia_buttons[i].classList.add("active");
}
</script>
</body>
````
